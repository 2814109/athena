package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"fmt"
	"my_gql_server/graph/model"
	"my_gql_server/infrastructures/repositories"
	"my_gql_server/my_models"

	lop "github.com/samber/lo/parallel"
)

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context, userID int) ([]*models.Todo, error) {
	todos, err := repositories.FindAllTodoByUserId(ctx, userID)

	if err != nil {
		return nil, err
	}

	result := lop.Map(todos, func(todo *models.Todo, _ int) *models.Todo {
		return todo

	})

	return result, nil
}

// Todo is the resolver for the todo field.
func (r *queryResolver) Todo(ctx context.Context, id int) (*models.Todo, error) {
	todo, err := repositories.FindTodoByID(ctx, id)

	if err != nil {
		return nil, err
	}

	return todo, nil
}

// Articles is the resolver for the articles field.
func (r *queryResolver) Articles(ctx context.Context, status model.ArticleStatuses) ([]*models.Article, error) {
	articles, err := repositories.FindAllArticle(ctx, status)

	if err != nil {
		return nil, err
	}

	result := lop.Map(articles, func(article *models.Article, _ int) *models.Article {
		return article

	})

	return result, nil
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, userID int) ([]*models.Item, error) {
	items, err := repositories.FindAllItemByUserId(ctx, userID)

	if err != nil {
		return nil, err
	}

	result := lop.Map(items, func(item *models.Item, _ int) *models.Item {
		return item

	})

	return result, nil
}

// Entries is the resolver for the entries field.
func (r *queryResolver) Entries(ctx context.Context) ([]*models.Entry, error) {
	panic(fmt.Errorf("not implemented: Entries - entries"))
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
